///////////////////////////////////////////////////////////////////////
// Class:       BeamPartIDEff
// Module Type: analyzer
// File:        BeamPartIDEff_module.cc
////////////////////////////////////////////////////////////////////////




#include<unistd.h>

//basic includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//framework includes
#include "art_root_io/TFileService.h"

#include "dunecore/DuneObj/ProtoDUNEBeamEvent.h"
#include "protoduneana/Utilities/ProtoDUNETrackUtils.h"
#include "protoduneana/Utilities/ProtoDUNEShowerUtils.h"
#include "protoduneana/Utilities/ProtoDUNETruthUtils.h"
#include "protoduneana/Utilities/ProtoDUNEPFParticleUtils.h"
#include "protoduneana/Utilities/ProtoDUNEBeamlineUtils.h"
#include "protoduneana/Utilities/ProtoDUNEEmptyEventFinder.h"
#include "protoduneana/Utilities/ProtoDUNEBeamCuts.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/ArtDataHelper/MVAReader.h"
#include "lardataobj/RecoBase/Wire.h"
#include "protoduneana/Utilities/ProtoDUNECalibration.h"


//root includes
#include "TTree.h"
#include "TVector3.h"
#include "TProfile.h"
#include "TFile.h"

namespace highlandAnalysis {

  class BeamPartIDEff;  

}

class highlandAnalysis::BeamPartIDEff : public art::EDAnalyzer {
public:
  explicit BeamPartIDEff(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  BeamPartIDEff(BeamPartIDEff const &) = delete;
  BeamPartIDEff(BeamPartIDEff &&) = delete;
  BeamPartIDEff & operator = (BeamPartIDEff const &) = delete;
  BeamPartIDEff & operator = (BeamPartIDEff &&) = delete;
  
  // Required functions.
  void analyze(art::Event const & e) override;
  
  // Selected optional functions
  void beginJob() override;
  void endJob() override;
  void reset();

  // Extra
  bool BeamHasOneTrack(art::Event const & evt);
  void IncreaseDenominator(art::Event const & evt);
  void IncreaseNumerator(art::Event const & evt);
  
private:

  TTree* fTree;
  
  // fcl parameters
  std::string fBeamModuleLabel;
  protoana::ProtoDUNEBeamlineUtils fBeamlineUtils;
  protoana::ProtoDUNEEmptyEventFinder fEmptyEventFinder;
  std::string fPFParticleTag;
  std::string fGeneratorTag;
  std::string fCosmicGeneratorTag;
  std::string fTrackerTag;
  std::string fShowerTag;
  std::string fHitTag;
  std::string fCalorimetryTag;
  double      fNominalBeamMom;

  //forward declartion for calling functions in an easier way
  protoana::ProtoDUNETruthUtils truthUtil;
  protoana::ProtoDUNEPFParticleUtils pfpUtil;
  protoana::ProtoDUNETrackUtils trackUtil;
  art::ServiceHandle<cheat::ParticleInventoryService> piServ;

  //counters for efficiency
  int fPLikeBeamEvents;
  int fPiLikeBeamEvents;
  int fKLikeBeamEvents;
  int fPLikeBeamEventsReconstructed;
  int fPiLikeBeamEventsReconstructed;
  int fKLikeBeamEventsReconstructed;
  bool fIsPLike;
  bool fIsPiLike;
  bool fIsKLike;
};

//*****************************************************************************
highlandAnalysis::BeamPartIDEff::BeamPartIDEff(fhicl::ParameterSet const & p)
//*****************************************************************************
  :
  EDAnalyzer(p),
  fBeamModuleLabel(p.get<std::string>("BeamModuleLabel")),
  fBeamlineUtils(p.get< fhicl::ParameterSet >("BeamlineUtils")),
  fEmptyEventFinder(p.get< fhicl::ParameterSet >("EmptyEventFinder")),
  fPFParticleTag(p.get<std::string>("PFParticleTag")),
  fGeneratorTag(p.get<std::string>("GeneratorTag")),
  fCosmicGeneratorTag(p.get<std::string>("CosmicGeneratorTag")),
  fTrackerTag(p.get<std::string>("TrackerTag")),
  fShowerTag(p.get<std::string>("ShowerTag")),
  fHitTag(p.get<std::string>("HitTag")),
  fCalorimetryTag(p.get<std::string>("CalorimetryTag")),
  fNominalBeamMom(p.get<double>("NominalBeamMom")){

  fPLikeBeamEvents = 0;
  fPiLikeBeamEvents = 0;
  fKLikeBeamEvents = 0;
  fPLikeBeamEventsReconstructed = 0;
  fPiLikeBeamEventsReconstructed = 0;
  fKLikeBeamEventsReconstructed = 0;
}

//*****************************************************************************
void highlandAnalysis::BeamPartIDEff::analyze(art::Event const & evt){
//*****************************************************************************

  reset();

  //1. The beam trigger is active (assume it is?).
  
  //2. A single track reconstructed in the beam monitors inmediately upstream of ProtoDUNE-SP.
  if(!BeamHasOneTrack(evt))return;
  
  //3. The detector high voltage is stable at -180 kV (fcl file).

  //4. The readout electronics on the beam-side of the detector are active (assume they are?).
  
  //5. There are least 10 3D hits in the region where the beam particle enters the detector.
  if(fEmptyEventFinder.IsEmptyEvent(evt))return;

  //if here, one more event to add to the denominator
  IncreaseDenominator(evt);

  //increase numerator 
  IncreaseNumerator(evt);

}

//*****************************************************************************
bool highlandAnalysis::BeamPartIDEff::BeamHasOneTrack(art::Event const & evt){
//*****************************************************************************
  
  if(evt.isRealData()){
    auto beamHandle = evt.getValidHandle<std::vector<beam::ProtoDUNEBeamEvent>>(fBeamModuleLabel);
    std::vector<art::Ptr<beam::ProtoDUNEBeamEvent>> beamVec;
    
    if(beamHandle.isValid()){
      art::fill_ptr_vector(beamVec, beamHandle);
    }
    
    const beam::ProtoDUNEBeamEvent & beamEvent = *(beamVec.at(0)); //Should just have one
    
    return beamEvent.GetBeamTracks().size() == 1;
  }
  
  else{
    auto mcTruths = evt.getValidHandle<std::vector<simb::MCTruth>>(fGeneratorTag);
    const simb::MCParticle* ls_truePrimaryPart = truthUtil.GetGeantGoodParticle((*mcTruths)[0],evt);
    if(!ls_truePrimaryPart)return false;
    else return true;
  }
}

//*****************************************************************************
void highlandAnalysis::BeamPartIDEff::IncreaseDenominator(art::Event const & evt){
//*****************************************************************************

  if(evt.isRealData()){
    auto beamHandle = evt.getValidHandle<std::vector<beam::ProtoDUNEBeamEvent>>(fBeamModuleLabel);
    std::vector<art::Ptr<beam::ProtoDUNEBeamEvent>> beamVec;

    if(beamHandle.isValid()){
      art::fill_ptr_vector(beamVec, beamHandle);
    }

    const beam::ProtoDUNEBeamEvent & beamEvent = *(beamVec.at(0)); //Should just have one
    
    std::vector<int> pdgs = fBeamlineUtils.GetPID(beamEvent, fNominalBeamMom);
    
    for(int i = 0; i < (int)pdgs.size(); i++){
      if(pdgs[i] == 211)      {fPiLikeBeamEvents++; fIsPiLike = true; break;}
      else if(pdgs[i] == 2212){fPLikeBeamEvents++;  fIsPLike  = true; break;}
      else if(pdgs[i] == 321) {fKLikeBeamEvents++;  fIsKLike  = true; break;}
    }
  }

  else{
    auto mcTruths = evt.getValidHandle<std::vector<simb::MCTruth>>(fGeneratorTag);
    const simb::MCParticle* ls_truePrimaryPart = truthUtil.GetGeantGoodParticle((*mcTruths)[0],evt);
    int pdg = abs(ls_truePrimaryPart->PdgCode());
    if(pdg == 11 || pdg == 13 || pdg == 211){fPiLikeBeamEvents++; fIsPiLike = true;}
    else if(pdg == 2212)                    {fPLikeBeamEvents++;  fIsPLike  = true;}
    else if(pdg == 321)                     {fKLikeBeamEvents++;  fIsKLike  = true;}
  }
}

//*****************************************************************************
void highlandAnalysis::BeamPartIDEff::IncreaseNumerator(art::Event const & evt){
//*****************************************************************************

  //Get the primary PFParticle and the vector of PFParticles
  std::vector<const recob::PFParticle*> primaryParticles = pfpUtil.GetPFParticlesFromBeamSlice(evt,fPFParticleTag);
  auto pfpVec = evt.getValidHandle<std::vector<recob::PFParticle>>(fPFParticleTag);

  if(primaryParticles.size() == 0)return;

  //if here, increase numerator
  if     (fIsPiLike)fPiLikeBeamEventsReconstructed++;
  else if(fIsPLike) fPLikeBeamEventsReconstructed++;
  else if(fIsKLike) fKLikeBeamEventsReconstructed++;
}

//*****************************************************************************
void highlandAnalysis::BeamPartIDEff::beginJob(){
//*****************************************************************************

  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("EffTree","Efficiency Tree");
  fTree->Branch("PLikeBeamEvents",  &fPLikeBeamEvents);
  fTree->Branch("PiLikeBeamEvents", &fPiLikeBeamEvents);
  fTree->Branch("KLikeBeamEvents",  &fKLikeBeamEvents);
  fTree->Branch("PLikeBeamEvents",  &fPLikeBeamEventsReconstructed);
  fTree->Branch("PiLikeBeamEvents", &fPiLikeBeamEventsReconstructed);
  fTree->Branch("KLikeBeamEvents",  &fKLikeBeamEventsReconstructed);
}

//*****************************************************************************
void highlandAnalysis::BeamPartIDEff::endJob(){
//*****************************************************************************
  
  fTree->Fill();
}

//*****************************************************************************
void highlandAnalysis::BeamPartIDEff::reset(){
//*****************************************************************************
  
  fIsPiLike = false;
  fIsPLike = false;
  fIsKLike = false;
}

DEFINE_ART_MODULE(highlandAnalysis::BeamPartIDEff)
