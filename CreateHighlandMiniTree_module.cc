///////////////////////////////////////////////////////////////////////
// Class:       CreateHighlandMiniTree
// Module Type: analyzer
// File:        CreateHighlandMiniTree_module.cc
//
// Generated at Fri Nov 20 08:01:58 2020 by Miguel Garcia Peris using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include<unistd.h>

//basic includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//framework includes
#include "art_root_io/TFileService.h"

#include "dunecore/DuneObj/ProtoDUNEBeamEvent.h"
#include "protoduneana/Utilities/ProtoDUNETrackUtils.h"
#include "protoduneana/Utilities/ProtoDUNEShowerUtils.h"
#include "protoduneana/Utilities/ProtoDUNETruthUtils.h"
#include "protoduneana/Utilities/ProtoDUNEPFParticleUtils.h"
#include "protoduneana/Utilities/ProtoDUNEBeamlineUtils.h"
#include "protoduneana/Utilities/ProtoDUNEBeamCuts.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/ArtDataHelper/MVAReader.h"
#include "lardataobj/RecoBase/Wire.h"
#include "lardataobj/RecoBase/SpacePoint.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"
#include "protoduneana/Utilities/ProtoDUNECalibration.h"

//root includes
#include "TTree.h"
#include "TVector3.h"
#include "TProfile.h"
#include "TFile.h"

//highland includes
#include "pdDataClasses.hxx"
#include "Header.hxx"
#include "pdAnalysisUtils.hxx"

namespace highlandAnalysis {
  
  class CreateHighlandMiniTree;  

}

class highlandAnalysis::CreateHighlandMiniTree : public art::EDAnalyzer {
public:
  explicit CreateHighlandMiniTree(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  CreateHighlandMiniTree(CreateHighlandMiniTree const &) = delete;
  CreateHighlandMiniTree(CreateHighlandMiniTree &&) = delete;
  CreateHighlandMiniTree & operator = (CreateHighlandMiniTree const &) = delete;
  CreateHighlandMiniTree & operator = (CreateHighlandMiniTree &&) = delete;
  
  // Required functions.
  void analyze(art::Event const & e) override;
  
  // Selected optional functions
  void beginJob() override;
  void endJob() override;
  void reset();

  // HighLAND functions
  AnaSpillPD*         MakeSpill()       { return new AnaSpillPD(); }
  AnaBunchPD*         MakeBunch()       { return new AnaBunchPD(); }
  AnaBeamPD*          MakeBeam()        { return new AnaBeamPD(); }
  AnaDataQualityB*    MakeDataQuality() { return new AnaDataQuality(); }
  AnaEventInfoPD*     MakeEventInfo()   { return new AnaEventInfoPD(); }

  AnaTrueParticlePD*  MakeTrueParticle(){ return new AnaTrueParticlePD(); }
  AnaTrueVertex*      MakeTrueVertex()  { return new AnaTrueVertex(); }
  AnaParticlePD*      MakeParticle()    { return new AnaParticlePD(); }

  // ----------------------------

  void FillDQInfo          (art::Event const &evt, AnaDataQuality* dq);
  void FillBeamTrueInfo    (art::Event const &evt, AnaSpill* spill);
  void FillTruePartInfo    (art::Event const &evt, const sim::ParticleList &pList, const simb::MCParticle* ls_truePart,
			    std::vector<AnaTrueParticleB*> &trueParticles, AnaTrueParticlePD* parent, 
			    int generation, bool recursive = true);
  void FillBeamInfo        (art::Event const &evt, AnaBeamPD* beam);
  void FillBunchInfo       (art::Event const &evt, std::vector<AnaTrueParticleB*>& trueParticles, AnaBunch* bunch, AnaSpillPD* spill);
  void FillParticleInfo    (art::Event const &evt, art::ValidHandle<std::vector<recob::PFParticle>> &pfpHandle, 
			    const recob::PFParticle* ls_part,
			    std::vector<AnaTrueParticleB*>& trueParticles, AnaBunch* bunch, 
			    int generation, bool BeamOrigin, bool isPandora = false);
  void FillTrackInfo       (art::Event const &evt, const recob::Track* track, AnaParticlePD* part);
  void FillShowerInfo      (const recob::Shower* shower, AnaParticlePD* part);
  void FillCosmicsTrueInfo (art::Event const &evt, std::vector<AnaTrueParticleB*>& trueParticles);
  void FillCosmicsInfo     (art::Event const &evt, std::vector<AnaTrueParticleB*>& trueParticles, AnaBunch* bunch);

  //other functions/utilities
  void CheckPrimaryMatching(std::vector<AnaTrueParticleB*>& trueParticles, AnaBunch* bunch);
  void TrueRecoMatching    (art::Event const &evt, const recob::PFParticle* ls_part, 
			    AnaParticlePD* part, std::vector<AnaTrueParticleB*>& trueParticles);

  AnaParticlePD* GetRecoParticle        (AnaBunch* bunch, int ID);
  AnaTrueParticlePD* GetTrueParticle    (std::vector<AnaTrueParticleB*>& trueParticles, int ID);
  int GetTrueParticleIDFromPFP          (art::Event const &evt, const recob::PFParticle* ls_part);

  bool IsInterestingCosmic(art::Event const &evt, const recob::PFParticle* ls_part);

  const simb::MCParticle* GetGeantGoodParticle(const simb::MCParticle &mcTruth);

  std::pair<float*,int> GetCNNOutputFromPFParticleFromPlane(const art::Event &evt, 
							    const anab::MVAReader<recob::Hit,4> &CNN_results,
							    protoana::ProtoDUNEPFParticleUtils& pfpUtil,
							    const recob::PFParticle &part,
							    int planeID);
  
  void WasteTime();

  
private:

  TTree* fTree;
  TTree* fHeaderTree;
  AnaSpillPD* fspill;

  std::map<int,TProfile*> PIDProfiles;
  
  // fcl parameters
  std::string fBeamModuleLabel;
  protoana::ProtoDUNEBeamlineUtils fBeamlineUtils;
  std::string fPFParticleTag;
  std::string fGeneratorTag;
  std::string fCosmicGeneratorTag;
  std::string fTrackerTag;
  std::string fShowerTag;
  std::string fHitTag;

  std::string fCalorimetryTag;
  std::string fCalorimetryTagNoSCE;

  std::string fPIDFilename;
  TFile *     fPIDFile;

  bool        fCosmics;
  
  int         fMaxGeneration;
  int         fMCMaxGeneration;

  double      fNominalBeamMom;

  bool        fDebug;

  bool        fWasteTime;
  int         fNLoopWT;

  //forward declartion for calling functions in an easier way
  protoana::ProtoDUNETruthUtils truthUtil;
  protoana::ProtoDUNEPFParticleUtils pfpUtil;
  protoana::ProtoDUNETrackUtils trackUtil;
  art::ServiceHandle<cheat::ParticleInventoryService> piServ;
};

//*****************************************************************************
highlandAnalysis::CreateHighlandMiniTree::CreateHighlandMiniTree(fhicl::ParameterSet const & p)
//*****************************************************************************
  :
  EDAnalyzer(p),
  fBeamModuleLabel(p.get<std::string>("BeamModuleLabel")),
  fBeamlineUtils(p.get< fhicl::ParameterSet >("BeamlineUtils")),
  fPFParticleTag(p.get<std::string>("PFParticleTag")),
  fGeneratorTag(p.get<std::string>("GeneratorTag")),
  fCosmicGeneratorTag(p.get<std::string>("CosmicGeneratorTag")),
  fTrackerTag(p.get<std::string>("TrackerTag")),
  fShowerTag(p.get<std::string>("ShowerTag")),
  fHitTag(p.get<std::string>("HitTag")),

  fCalorimetryTag(p.get<std::string>("CalorimetryTag")),
  fCalorimetryTagNoSCE(p.get<std::string>("CalorimetryTagNoSCE")),

  fPIDFilename(p.get<std::string>("PIDFilename")),

  fCosmics(p.get<bool>("Cosmics")),

  fMaxGeneration(p.get<int>("MaxGeneration")),
  fMCMaxGeneration(p.get<int>("MCMaxGeneration")),

  fNominalBeamMom(p.get<double>("NominalBeamMom")), 

  fDebug(p.get<bool>("Debug")),

  fWasteTime(p.get<bool>("WasteTime")),
  fNLoopWT(p.get<int>("NLoopWT")){

  fPIDFile = TFile::Open(fPIDFilename.c_str());
  PIDProfiles[211]  = (TProfile*)fPIDFile->Get("dedx_range_pi" );
  PIDProfiles[321]  = (TProfile*)fPIDFile->Get("dedx_range_ka" );
  PIDProfiles[13]   = (TProfile*)fPIDFile->Get("dedx_range_mu" );
  PIDProfiles[2212] = (TProfile*)fPIDFile->Get("dedx_range_pro");
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::analyze(art::Event const & evt){
//*****************************************************************************

  //create a spill for each event and fill event info
  AnaSpillPD* spill = MakeSpill();
  spill->EventInfo = MakeEventInfo();
 
  AnaEventInfoPD& info = *static_cast<AnaEventInfoPD*>(spill->EventInfo);
  info.Run    = evt.run();
  info.SubRun = evt.subRun();
  info.Event  = evt.id().event();
  info.IsMC   = !evt.isRealData();
  info.NominalBeamMom = fNominalBeamMom;

  if(fDebug){
    std::cout << "Run " << info.Run << ", event " << info.Event << ", MC = " << info.IsMC;
    std::cout << ", Beam Mom = " << info.NominalBeamMom << std::endl;
  }

  //data quality and check
  spill->DataQuality = MakeDataQuality();
  FillDQInfo(evt,static_cast<AnaDataQuality*>(spill->DataQuality));
  if(!static_cast<AnaDataQuality*>(spill->DataQuality)->GoodDaq){
    mf::LogVerbatim("CreateHighlandMiniTree") << "Beam quality check failed";
    return;
  }
 
  //true info
  if(info.IsMC){
    FillBeamTrueInfo(evt,spill);
    if(spill->TrueParticles.empty()){
      mf::LogVerbatim("CreateHighlandMiniTree") << "No true info found";
      return;
    }
    //get cosmics if desired
    //for the moment cosmics are only retrieved if the beam true info has been succesfully stored TODO make this independent
    if(fCosmics)FillCosmicsTrueInfo(evt, spill->TrueParticles);
  }
  
  //beam related information
  spill->Beam = MakeBeam();
  FillBeamInfo(evt, static_cast<AnaBeamPD*>(spill->Beam));
  //if it is a mc event, match the primary particle with the beam particle
  if(info.IsMC)static_cast<AnaBeam*>(spill->Beam)->BeamParticle->TrueObject = spill->TrueParticles.at(0);
  
  //Fill each bunch info (we have only one in PD)
  AnaBunch* bunch = MakeBunch();
  spill->Bunches.push_back(bunch);
  FillBunchInfo(evt, spill->TrueParticles, bunch, spill);
  if(bunch->Particles.empty()){
    mf::LogVerbatim("CreateHighlandMiniTree") << "Returning";
    return;
  }
  
  //check if primary particle is beam particle (MC only)
  if(info.IsMC)CheckPrimaryMatching(spill->TrueParticles, bunch);
  
  //get cosmics if desired
  //for the moment cosmics are only retrieved if the beam info has been succesfully stored
  if(fCosmics)FillCosmicsInfo(evt, spill->TrueParticles, bunch);
  
  //waste time if needed
  if(fWasteTime)WasteTime();

  //if spill has been correctly saved, delete previous one
  if(fspill)delete fspill;
  fspill = NULL;

  //clone the new spill and fill the three
  fspill = spill->Clone();
  fTree->Fill();
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillDQInfo(art::Event const &evt, AnaDataQuality* dq){
//*****************************************************************************

  if(fDebug)std::cout << "Filling data quality info" << std::endl;

  //associate trigger quality to data quality. Only for data, MC is always good.
  if(evt.isRealData())dq->GoodDaq = fBeamlineUtils.IsGoodBeamlineTrigger(evt);
  else dq->GoodDaq = true;

}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillBeamTrueInfo(art::Event const &evt, AnaSpill* spill){
//*****************************************************************************
  
  if(fDebug)std::cout << "Filling truth beam info" << std::endl;

  //get the truth particles
  auto mcTruths = evt.getValidHandle<std::vector<simb::MCTruth>>(fGeneratorTag);

  if(fDebug){
    std::cout << "there is a primary truth particle" << std::endl;
    std::cout << "and " << (*mcTruths)[0].NParticles()-1 << " truth background particles in this event" << std::endl;
  }

  //get true primary particle
  const simb::MCParticle* ls_truePrimaryPart = truthUtil.GetGeantGoodParticle((*mcTruths)[0],evt);
  if(!ls_truePrimaryPart){
    mf::LogVerbatim("CreateHighlandMiniTree") << "True primary particle not found" << std::endl;
    return;
  }
  if(fDebug)std::cout << "true primary particle found" << std::endl;

  //fill true particle info recursively
  const sim::ParticleList &pList = piServ->ParticleList();

  spill->TrueParticles.clear();
  
  int generation = 0;

  FillTruePartInfo(evt, pList, ls_truePrimaryPart, spill->TrueParticles, NULL, generation, true);
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillTruePartInfo(art::Event const &evt,
								const sim::ParticleList &pList,
								const simb::MCParticle* ls_truePart,
								std::vector<AnaTrueParticleB*>& trueParticles,
								AnaTrueParticlePD* parent,
								int generation,
								bool recursive){
//*****************************************************************************

  //create true particle and add it to the vector of true particles
  AnaTrueParticlePD* truePart = MakeTrueParticle();
  trueParticles.push_back(truePart);
 
  //fill truepart information
  truePart->ID       = ls_truePart->TrackId();
  truePart->ParentID = ls_truePart->Mother();
  truePart->Origin   = piServ->TrackIdToMCTruth_P(ls_truePart->TrackId())->Origin();
  if(truePart->Origin==0 && parent)truePart->Origin = parent->Origin; //if unknown origin, assign parent origin

  truePart->PDG                  = ls_truePart->PdgCode();
  if(parent)truePart->ParentPDG  = parent->PDG;
  if(parent)truePart->GParentPDG = parent->ParentPDG;

  truePart->Generation = generation;

  truePart->ProcessStart = truePart->ConvertProcess(ls_truePart->Process());
  truePart->ProcessEnd   = truePart->ConvertProcess(ls_truePart->EndProcess());

  truePart->Position[0] = ls_truePart->Position(0).X();
  truePart->Position[1] = ls_truePart->Position(0).Y();
  truePart->Position[2] = ls_truePart->Position(0).Z();

  truePart->PositionEnd[0] = ls_truePart->EndX();
  truePart->PositionEnd[1] = ls_truePart->EndY();
  truePart->PositionEnd[2] = ls_truePart->EndZ();

  truePart->Direction[0] = ls_truePart->Px()/ls_truePart->P();
  truePart->Direction[1] = ls_truePart->Py()/ls_truePart->P();
  truePart->Direction[2] = ls_truePart->Pz()/ls_truePart->P();

  size_t np = ls_truePart->NumberTrajectoryPoints();

  truePart->DirectionEnd[0] = ls_truePart->Px(np-2)/ls_truePart->P(np-2);
  truePart->DirectionEnd[1] = ls_truePart->Py(np-2)/ls_truePart->P(np-2);
  truePart->DirectionEnd[2] = ls_truePart->Pz(np-2)/ls_truePart->P(np-2);

  truePart->Momentum = ls_truePart->P();
  truePart->MomentumEnd = ls_truePart->P(np-2);

  //increment generation
  generation++;

  //go for daughters
  truePart->Daughters.clear();

  //loop over daughters to get their IDs
  for(int idau = 0; idau < ls_truePart->NumberDaughters(); idau++){
    //fill daughters ID vector
    truePart->Daughters.push_back(ls_truePart->Daughter(idau));
    //fill daughter info recursively if desired
    if(recursive){//we may want to fill the true info of a particle and not its daughters (e.g. missmatched cosmic particle)
      //get the daughter
      auto const ls_trueDau = pList[ls_truePart->Daughter(idau)];
      //skip delta rays
      if(ls_trueDau->Process() == "compt"  || ls_trueDau->Process() == "eIoni" ||
	 ls_trueDau->Process() == "hIoni"  || ls_trueDau->Process() == "muIoni" ||
	 ls_trueDau->Process() == "eBrem"  || ls_trueDau->Process() == "phot")continue;
      if(generation < fMCMaxGeneration && ls_truePart->NumberDaughters() > 0)
	FillTruePartInfo(evt, pList, ls_trueDau, trueParticles, truePart, generation, recursive);
    }
  }
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillBeamInfo(art::Event const &evt, AnaBeamPD* beam){
//*****************************************************************************

  if(fDebug)std::cout << "Filling beam info" << std::endl;

  //get vector of beam events, but use just the first one
  //some criteria is needed if more than 1 beam event is found
  std::string beamtag;
  if(evt.isRealData())beamtag = fBeamModuleLabel; // for data
  else beamtag = fGeneratorTag;                   // MC
  auto beamHandle = evt.getValidHandle<std::vector<beam::ProtoDUNEBeamEvent>>(beamtag);
  std::vector<art::Ptr<beam::ProtoDUNEBeamEvent>> beamVec;

  if(beamHandle.isValid()){
    art::fill_ptr_vector(beamVec, beamHandle);
  }

  const beam::ProtoDUNEBeamEvent & beamEvent = *(beamVec.at(0)); //Should just have one

  //fill beam intrumentation information
  beam->nTracks = beamEvent.GetBeamTracks().size();
  beam->nMomenta = beamEvent.GetRecoBeamMomenta().size();
   
  beam->TOF = beamEvent.GetTOF();

  std::vector< int > pdgs = fBeamlineUtils.GetPID(beamEvent, fNominalBeamMom);
  beam->PDGs.insert(beam->PDGs.end(), pdgs.begin(), pdgs.end());

  beam->nFibers[0] = beamEvent.GetActiveFibers( "XBPF022697" ).size();
  beam->nFibers[1] = beamEvent.GetActiveFibers( "XBPF022701" ).size();
  beam->nFibers[2] = beamEvent.GetActiveFibers( "XBPF022702" ).size();

  //create the beam particle
  beam->BeamParticle = MakeParticle();

  if(beam->nTracks > 0){

    if(beam->nMomenta > 0)beam->BeamParticle->Momentum = beamEvent.GetRecoBeamMomenta()[0];

    beam->BeamParticle->PositionStart[0] = beamEvent.GetBeamTracks()[0].Trajectory().Start().X();
    beam->BeamParticle->PositionStart[1] = beamEvent.GetBeamTracks()[0].Trajectory().Start().Y();
    beam->BeamParticle->PositionStart[2] = beamEvent.GetBeamTracks()[0].Trajectory().Start().Z();
    beam->BeamParticle->PositionEnd[0]   = beamEvent.GetBeamTracks()[0].Trajectory().End().X();
    beam->BeamParticle->PositionEnd[1]   = beamEvent.GetBeamTracks()[0].Trajectory().End().Y();
    beam->BeamParticle->PositionEnd[2]   = beamEvent.GetBeamTracks()[0].Trajectory().End().Z();

    beam->BeamParticle->DirectionStart[0] = beamEvent.GetBeamTracks()[0].Trajectory().StartDirection().X();
    beam->BeamParticle->DirectionStart[1] = beamEvent.GetBeamTracks()[0].Trajectory().StartDirection().Y();
    beam->BeamParticle->DirectionStart[2] = beamEvent.GetBeamTracks()[0].Trajectory().StartDirection().Z();
    beam->BeamParticle->DirectionEnd[0]   = beamEvent.GetBeamTracks()[0].Trajectory().EndDirection().X();
    beam->BeamParticle->DirectionEnd[1]   = beamEvent.GetBeamTracks()[0].Trajectory().EndDirection().Y();
    beam->BeamParticle->DirectionEnd[2]   = beamEvent.GetBeamTracks()[0].Trajectory().EndDirection().Z();
  }

  if(fDebug)std::cout << "beam information retrieved. Event has " << beam->nTracks << " tracks" << std::endl;
} 

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillBunchInfo(art::Event const &evt,
							     std::vector<AnaTrueParticleB*>& trueParticles,
							     AnaBunch* bunch, AnaSpillPD* spill){
//*****************************************************************************
  
  if(fDebug)std::cout << "Filling bunch info" << std::endl;

  //basic bunch info (there's only one bunch in PD)
  bunch->Bunch  = 1;
  bunch->Weight = 1;

  //Get the primary PFParticle and the vector of PFParticles
  std::vector<const recob::PFParticle*> primaryParticles = pfpUtil.GetPFParticlesFromBeamSlice(evt,fPFParticleTag);
  auto pfpHandle = evt.getValidHandle<std::vector<recob::PFParticle>>(fPFParticleTag);

  if(fDebug)std::cout << "there are " << (*pfpHandle).size() << " PFP particles in this event" << std::endl;

  if(primaryParticles.size() == 0){
    std::cout << "No primary particle found" << std::endl;
    return;
  }

  //get the primary particle
  const recob::PFParticle* ls_primaryPart = primaryParticles.at(0);

  //clear particles vector
  bunch->Particles.clear();

  //fill particle info recursively
  int generation  = 0;
  bool BeamOrigin = true;
  bool isPandora  = true;
  
  if(fDebug)std::cout << "Filling particle info recursively" << std::endl;
  FillParticleInfo(evt, pfpHandle, ls_primaryPart, trueParticles, bunch, generation, BeamOrigin, isPandora);
}


//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillParticleInfo(art::Event const &evt,
								art::ValidHandle<std::vector<recob::PFParticle>> &pfpHandle,
								const recob::PFParticle* ls_part,
								std::vector<AnaTrueParticleB*>& trueParticles,
								AnaBunch* bunch, int generation, bool BeamOrigin, bool isPandora){
//*****************************************************************************

  //create AnaParticle and add it to the bunch
  AnaParticlePD* part = MakeParticle();
  bunch->Particles.push_back(part);

  //if mc try to match a truth particle
  if(!evt.isRealData())TrueRecoMatching(evt, ls_part, part, trueParticles);
 
  //fill PFP basic info
  part->isPandora  = isPandora;
  part->BeamOrigin = BeamOrigin;

  part->UniqueID = ls_part->Self();
  part->ParentID = ls_part->Parent();
  
  part->Generation = generation;

  //get number of hits of the PFP regardless track or shower
  const std::vector<art::Ptr<recob::Hit>> ls_part_hits = pfpUtil.GetPFParticleHits_Ptrs(*ls_part, evt, fPFParticleTag);
  part->NHits = ls_part_hits.size();

  // Determine if the particle is track-like or shower-like
  const recob::Track*  track  = pfpUtil.GetPFParticleTrack(*ls_part,evt,fPFParticleTag,fTrackerTag);
  const recob::Shower* shower = pfpUtil.GetPFParticleShower(*ls_part,evt,fPFParticleTag,fShowerTag);

  //fill track-like info or showerlike info
  if(track) FillTrackInfo(evt,track,part);
  if(shower)FillShowerInfo(shower,part);

  //go for CNN
  //CNN Outputs: Track, EM, Michel, Empty
  anab::MVAReader<recob::Hit,4> mvaReader(evt, "emtrkmichelid:emtrkmichel");
  //get cnn for plane 2
  std::pair<float*, int> cnnResult = GetCNNOutputFromPFParticleFromPlane(evt, mvaReader, pfpUtil, *ls_part, 2);
  for(int i = 0; i < 3; i++)part->CNNscore[i] = cnnResult.first[i] / cnnResult.second;

  //increment generation
  generation++;

  //go for daughters
  part->DaughtersIDs.clear();

  //loop over daughters
  for(int idau = 0; idau < ls_part->NumDaughters(); idau++){
    //get daughter matching id
    const recob::PFParticle* ls_dau = &(pfpHandle->at(ls_part->Daughter(idau)));
    //fill daughters id vector
    part->DaughtersIDs.push_back(ls_dau->Self());
    //fill daughter info
    if(generation < fMaxGeneration)
      FillParticleInfo(evt, pfpHandle, ls_dau, trueParticles, bunch, generation, BeamOrigin);
  }
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillTrackInfo(art::Event const &evt, const recob::Track* track, AnaParticlePD* part){
//*****************************************************************************

  //fill track basic info
  part->Type = AnaParticlePD::kTrack;
  
  part->PositionStart[0] = track->Start().X();
  part->PositionStart[1] = track->Start().Y();
  part->PositionStart[2] = track->Start().Z();
  
  part->PositionEnd[0] = track->End().X();
  part->PositionEnd[1] = track->End().Y();
  part->PositionEnd[2] = track->End().Z();
    
  part->DirectionStart[0] = track->StartDirection().X();
  part->DirectionStart[1] = track->StartDirection().Y();
  part->DirectionStart[2] = track->StartDirection().Z();
  
  part->DirectionEnd[0] = track->EndDirection().X();
  part->DirectionEnd[1] = track->EndDirection().Y();
  part->DirectionEnd[2] = track->EndDirection().Z();
    
  part->Length = track->Length();

  //fill hit basic info
  for(int iplane = 0; iplane < 3; iplane++)part->Hits[iplane].clear();

  //get calo information
  std::vector<anab::Calorimetry> calo = trackUtil.GetRecoTrackCalorimetry(*track, evt, fTrackerTag, fCalorimetryTag);
  std::vector<anab::Calorimetry> calonosce = trackUtil.GetRecoTrackCalorimetry(*track, evt, fTrackerTag, fCalorimetryTagNoSCE);

  //safety check
  if(calo.empty() || calonosce.empty())return;

  //get collection plane index (it changes within productions and data/MC)
  int plane_index = -1;
  int plane_index_nosce = -1;
  for(int i = 0; i < (int)calo.size(); i++){
    if(calo[i].PlaneID().Plane == 2){
      plane_index = i;
      break;
    }
  }
  for(int i = 0; i < (int)calonosce.size(); i++){
    if(calonosce[i].PlaneID().Plane == 2){
      plane_index_nosce = i;
      break;
    }
  }
  if(plane_index==-1 || plane_index_nosce==-1){
    if(fDebug)std::cout << "No collection plane founde" << std::endl;
    return;
  }

  //get a handle of all hits
  auto hitHandle = evt.getValidHandle<std::vector<recob::Hit>>(fHitTag);
  std::vector<art::Ptr<recob::Hit>> hitVec;
  art::fill_ptr_vector(hitVec, hitHandle);
  
  //get the hits and metadata associated to every track in the event for SCE pitch correction (probably this could be done globally only once)
  auto trackHandle = evt.getValidHandle<std::vector<recob::Track>>(fTrackerTag);
  std::vector<art::Ptr<recob::Track>> trackVec;
  art::fill_ptr_vector(trackVec, trackHandle);
  art::FindManyP<recob::Hit, recob::TrackHitMeta> fmthm(trackHandle,evt,fTrackerTag); 
  
  std::vector<const recob::TrackHitMeta*, std::allocator<const recob::TrackHitMeta*>> metaVec;
  std::vector<art::Ptr<recob::Hit>> hitVec2;
  //get metadata for this track
  if(fmthm.isValid()){
    metaVec = fmthm.data(track->ID());
    hitVec2 = fmthm.at(track->ID());
  }

  //number of hits
  part->NHitsPerPlane[2] = calo[plane_index].dQdx().size();

  //for chi2 calculation
  std::vector<double> dEdx;
  std::vector<double> ResRange;
  dEdx.clear();
  ResRange.clear();

  //fil hit info
  for(int ihit = 0; ihit < (int)calo[plane_index].dQdx().size(); ihit++){
    //create a highland hit 
    AnaHitPD hit;
    
    //fill calibrated calorimetry info
    hit.dQdx          = calo[plane_index].dQdx().at(ihit);
    hit.dEdx          = calo[plane_index].dEdx().at(ihit);
    hit.ResidualRange = calo[plane_index].ResidualRange().at(ihit);
    hit.Pitch         = calo[plane_index].TrkPitchVec().at(ihit);
    hit.Position.SetXYZ(calo[plane_index].XYZ().at(ihit).X(), 
			calo[plane_index].XYZ().at(ihit).Y(), 
			calo[plane_index].XYZ().at(ihit).Z());

    //fill raw calorimetry info
    hit.dQdx_NoSCE          = calonosce[plane_index_nosce].dQdx().at(ihit);
    hit.dEdx_NoSCE          = calonosce[plane_index_nosce].dEdx().at(ihit);
    hit.ResidualRange_NoSCE = calonosce[plane_index].ResidualRange().at(ihit);
    hit.Pitch_NoSCE         = calonosce[plane_index_nosce].TrkPitchVec().at(ihit);
    hit.Position_NoSCE.SetXYZ(calonosce[plane_index_nosce].XYZ().at(ihit).X(),
			      calonosce[plane_index_nosce].XYZ().at(ihit).Y(),
			      calonosce[plane_index_nosce].XYZ().at(ihit).Z());

    //extra information for calibrations
    //this is the hit used to fill the calorimetry object
    art::Ptr<recob::Hit> ls_hit = hitVec[calo[plane_index].TpIndices().at(ihit)];

    //look for the same hit in the track-meta association
    for(int iss = 0; iss < (int)hitVec2.size(); iss++){
      if(hitVec2[iss].key()==ls_hit.key()){
	//now, from the meta, get the space point in the track and the direction of the hit
	hit.Direction_NoSCE.SetXYZ(track->DirectionAtPoint(metaVec[iss]->Index()).X(),
				   track->DirectionAtPoint(metaVec[iss]->Index()).Y(),
				   track->DirectionAtPoint(metaVec[iss]->Index()).Z());
      }
    }

    hit.TPCid = ls_hit->WireID().TPC;
    hit.PlaneID = 2; //we only save collection plane information

    //fill vectors for chi2 calculation
    dEdx.push_back(hit.dEdx);
    ResRange.push_back(hit.ResidualRange);
    
    //add hit to vector of hits
    part->Hits[2].push_back(hit);
  }

  //get PID
  std::pair<double,int> proton_PID = trackUtil.Chi2PID(dEdx,ResRange,PIDProfiles[2212]);
  std::pair<double,int> muon_PID   = trackUtil.Chi2PID(dEdx,ResRange,PIDProfiles[13]  );
  part->Chi2Proton = proton_PID.first;
  part->Chi2Muon   = muon_PID.first;
  part->Chi2ndf    = proton_PID.second;
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillShowerInfo(const recob::Shower* shower, AnaParticlePD* part){
//*****************************************************************************

  //fill shower basic info
  part->Type = AnaParticlePD::kShower;

  part->PositionStart[0] = shower->ShowerStart().X();
  part->PositionStart[1] = shower->ShowerStart().Y();
  part->PositionStart[2] = shower->ShowerStart().Z();
  
  part->DirectionStart[0] = shower->Direction().X();
  part->DirectionStart[1] = shower->Direction().Y();
  part->DirectionStart[2] = shower->Direction().Z();
  
  part->Length = shower->Length();

  //probably there are many other variables to add here but I don't need them for kaon analysis.
  //they will be added as needed/requested
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillCosmicsTrueInfo(art::Event const &evt,
								   std::vector<AnaTrueParticleB*>& trueParticles){
//*****************************************************************************

  if(fDebug)std::cout << "filling cosmics true info" << std::endl;
  
  //get the truth particles
  auto mcTruths = evt.getValidHandle<std::vector<simb::MCTruth>>(fCosmicGeneratorTag);

  if(fDebug)std::cout << "there are " << (*mcTruths)[0].NParticles() << " cosmic truth particles in this event" << std::endl;
  
  const sim::ParticleList &pList = piServ->ParticleList();
  //loop over truth particles
  for(int i = 0; i < (*mcTruths)[0].NParticles(); i++){
    const simb::MCParticle* ls_trueCosmic = GetGeantGoodParticle((*mcTruths)[0].GetParticle(i));
    if(ls_trueCosmic){//safety check
      if(!GetTrueParticle(trueParticles,ls_trueCosmic->TrackId())){//safety check
	int generation = 0;
	FillTruePartInfo(evt, pList, ls_trueCosmic, trueParticles, NULL, generation, true);
      }
    }
  }
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::FillCosmicsInfo(art::Event const &evt,
							       std::vector<AnaTrueParticleB*>& trueParticles,
							       AnaBunch* bunch){
//*****************************************************************************

  if(fDebug)std::cout << "filling cosmics info" << std::endl;
  
  //get vector of pfp particles
  auto pfpHandle = evt.getValidHandle<std::vector<recob::PFParticle>>(fPFParticleTag);
  if(fDebug)std::cout << "there are " << (*pfpHandle).size() << " PFP particles in this event" << std::endl;

  int cosmics = 0; 

  //look for interesting cosmics and add them to the particle vector if they have not been added previously
  for(const recob::PFParticle ls_part : (*pfpHandle)){
    if(!GetRecoParticle(bunch, ls_part.Self())){
      if(IsInterestingCosmic(evt,&ls_part)){
	cosmics++;
	FillParticleInfo(evt, pfpHandle, &ls_part, trueParticles, bunch, -1, false);
      }
    }
  }
  std::cout << cosmics << " interesting cosmics added to the particles vector" << std::endl;
}

//*****************************************************************************
bool highlandAnalysis::CreateHighlandMiniTree::IsInterestingCosmic(art::Event const &evt, const recob::PFParticle* ls_part){
//*****************************************************************************
  
  bool ItIs = false;

  //const recob::Track* track = pfpUtil.GetPFParticleTrack(*ls_part,evt,fPFParticleTag,fTrackerTag);
  //if(!track)return ItIs;

  //we are only interested in cosmic rays which interact in the detector volume and generate secondary particles
  if(ls_part->IsPrimary())ItIs = true;
     //&& ls_part->NumDaughters() > 0 &&
     //abs(track->End().X()) < 310 && 
     //abs(track->End().Y()-300) < 250 &&
     //abs(track->End().Z()-350) < 300)ItIs = true;

  return ItIs;
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::CheckPrimaryMatching(std::vector<AnaTrueParticleB*>& trueParticles, 
								    AnaBunch* bunch){
//*****************************************************************************

  //sanity check
  if(trueParticles.size() == 0 || bunch->Particles.size() == 0)return;

  AnaTrueParticlePD* tp1 = static_cast<AnaTrueParticlePD*>(trueParticles.at(0));
  AnaTrueParticlePD* tp2 = static_cast<AnaTrueParticlePD*>(bunch->Particles.at(0)->TrueObject);
  if(tp1 && tp2){
    if(tp1->ID == tp2->ID){
      static_cast<AnaTrueParticlePD*>(bunch->Particles.at(0)->TrueObject)->Matched = true;
      if(fDebug)std::cout << "Primary particle in TPC and beam particle matched" << std::endl;
    }
    else {
      static_cast<AnaTrueParticlePD*>(bunch->Particles.at(0)->TrueObject)->Matched = false;
      if(fDebug)std::cout << "Primary part missmatched" << std::endl;
    }
  }
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::TrueRecoMatching(art::Event const &evt, const recob::PFParticle* ls_part, 
							       AnaParticlePD* part, std::vector<AnaTrueParticleB*>& trueParticles){
//*****************************************************************************

  bool found = false;

  //get the true particle ID that generated this reco particle
  int truePartID = GetTrueParticleIDFromPFP(evt, ls_part);

  //look for it in the TrueParticles vector
  for(int itrue = 0; itrue < (int)trueParticles.size(); itrue++){
    if(truePartID == trueParticles.at(itrue)->ID){
      //if(fDebug)std::cout << "matching true particle found" << std::endl;
      part->TrueObject = trueParticles.at(itrue);
      found = true;
      break;
    }
  }

  //if not found among stored true particles, look for it on the pList
  if(!found){
    if(fDebug)std::cout << "matching true particle not found among previously stored trueparticles," << std::endl;
    const sim::ParticleList &pList = piServ->ParticleList();
    for(auto const ls_truePart : pList){
      if(ls_truePart.second->TrackId() == truePartID){
	//if(fDebug)std::cout << "matching true particle found" << std::endl;
	FillTruePartInfo(evt, pList, ls_truePart.second, trueParticles, NULL, -999, false);
	part->TrueObject = trueParticles.back();
	found = true;
	break;
      }
    }
  }
  
  if(!found)if(fDebug)std::cout << "matching true particle not found anywhere" << std::endl;
}

//*****************************************************************************
AnaParticlePD* highlandAnalysis::CreateHighlandMiniTree::GetRecoParticle(AnaBunch* bunch, int ID){
//*****************************************************************************

  AnaParticlePD* part = NULL;

  //loop over stored particles
  for(int i = 0; i < (int)bunch->Particles.size(); i++){
    if(bunch->Particles[i]->UniqueID == ID){
      part = static_cast<AnaParticlePD*>(bunch->Particles[i]);
      break;
    }
  }

  return part;
}

//*****************************************************************************
AnaTrueParticlePD* highlandAnalysis::CreateHighlandMiniTree::GetTrueParticle(std::vector<AnaTrueParticleB*>& trueParticles, int ID){
//*****************************************************************************

  AnaTrueParticlePD* truePart = NULL;

  //loop over stored true particles
  for(int i = 0; i < (int)trueParticles.size(); i++){
    if(trueParticles[i]->ID == ID){
      truePart = static_cast<AnaTrueParticlePD*>(trueParticles[i]);
      break;
    }
  }

  return truePart;
}

//*****************************************************************************
int highlandAnalysis::CreateHighlandMiniTree::GetTrueParticleIDFromPFP(art::Event const &evt, const recob::PFParticle* ls_part){
//*****************************************************************************

  //create a clock instance
  auto const clockData = art::ServiceHandle<detinfo::DetectorClocksService>()->DataFor(evt);

  //look for the MCParticle that most probably generated the PFParticle
  const simb::MCParticle* ls_truePart = truthUtil.GetMCParticleFromPFParticle(clockData, *ls_part, evt, fPFParticleTag);

  if(ls_truePart)return ls_truePart->TrackId();
  else return -1;
}

//*****************************************************************************
const simb::MCParticle* highlandAnalysis::CreateHighlandMiniTree::GetGeantGoodParticle(const simb::MCParticle &mcTruth){
//*****************************************************************************

  const sim::ParticleList & plist = piServ->ParticleList();

  for(auto const part : plist){
    if((mcTruth.PdgCode() == part.second->PdgCode()) && fabs(part.second->E() - mcTruth.E()) < 1e-5){
      return part.second;
    }
  }

  return NULL;
}

//*****************************************************************************
std::pair<float*, int> highlandAnalysis::CreateHighlandMiniTree::
GetCNNOutputFromPFParticleFromPlane(const art::Event &evt,
				    const anab::MVAReader<recob::Hit,4> &CNN_results,
				    protoana::ProtoDUNEPFParticleUtils& pfpUtil, 
				    const recob::PFParticle &part,
				    int planeID){
//*****************************************************************************
  
  //get hits from plane
  const std::vector<art::Ptr<recob::Hit>> daughterPFP_hits = 
    pfpUtil.GetPFParticleHitsFromPlane_Ptrs(part, evt, fPFParticleTag, planeID);
  
  //loop over hits
  float cnn[4] = {0};
  int nhits = 0;
  for(int ihit = 0; ihit < (int)daughterPFP_hits.size(); ihit++){
    std::array<float,4> cnn_out = CNN_results.getOutput(daughterPFP_hits[ihit]);
    cnn[0] += cnn_out[ CNN_results.getIndex("track") ];
    cnn[1] += cnn_out[ CNN_results.getIndex("em") ];
    cnn[2] += cnn_out[ CNN_results.getIndex("michel") ];
    cnn[3] += cnn_out[ CNN_results.getIndex("none") ];
    nhits++;
  }
  
  std::pair<float*, int> output(cnn, nhits);
  
  return output;
}


//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::beginJob(){
//*****************************************************************************

  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("MiniTree","event model tree");
  fspill = NULL;
  fTree->Branch("Spill", "AnaSpillPD", &fspill,64000,1);

  
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::endJob(){
//*****************************************************************************
  
  //create header file
  art::ServiceHandle<art::TFileService> tfs;
  fHeaderTree = tfs->make<TTree>("header","header tree");
  Header* headerp = NULL;                                                                                                         
  fHeaderTree->Branch("POTInfo","Header",&headerp,32000,0);                                                                
  fHeaderTree->Fill();

  //delete last spill before exiting
  delete fspill;

  //close PID file
  fPIDFile->Close();

}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::reset(){
//*****************************************************************************
  
}

//*****************************************************************************
void highlandAnalysis::CreateHighlandMiniTree::WasteTime(){
//*****************************************************************************
  
  std::cout << "as my module runs too fast compared with the amount of time it takes to open rootfiles, I need to increase the CPU time so I don't get low efficiency warnings :(" << std::endl;
  int x = 0;
  
  for(int i = 0; i < fNLoopWT; i++){
    for(int j = 0; j < fNLoopWT; j++){
      for(int k = 0; k < fNLoopWT; k++){
	for(int l = 0; l < fNLoopWT; l++){
	  x = x + pow(-1,i+j+k+l);
	}
      }
    }
  }
  std::cout << "the result of this amazing waste of time is " << x << std::endl;
}

DEFINE_ART_MODULE(highlandAnalysis::CreateHighlandMiniTree)
