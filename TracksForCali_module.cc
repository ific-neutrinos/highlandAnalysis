#include<unistd.h>

//basic includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

//framework includes
#include "art_root_io/TFileService.h"

#include "dunecore/DuneObj/ProtoDUNEBeamEvent.h"
#include "protoduneana/Utilities/ProtoDUNETrackUtils.h"
#include "protoduneana/Utilities/ProtoDUNEShowerUtils.h"
#include "protoduneana/Utilities/ProtoDUNETruthUtils.h"
#include "protoduneana/Utilities/ProtoDUNEPFParticleUtils.h"
#include "protoduneana/Utilities/ProtoDUNEBeamlineUtils.h"
#include "protoduneana/Utilities/ProtoDUNEBeamCuts.h"
#include "larsim/MCCheater/ParticleInventoryService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/ArtDataHelper/MVAReader.h"
#include "lardataobj/RecoBase/Wire.h"
#include "protoduneana/Utilities/ProtoDUNECalibration.h"

//root includes
#include "TTree.h"
#include "TVector3.h"
#include "TFile.h"

//highland includes
#include "pdDataClasses.hxx"
#include "Header.hxx"

namespace highlandAnalysis {
  
  class TracksForCali;  

}

class highlandAnalysis::TracksForCali : public art::EDAnalyzer {
public:
  explicit TracksForCali(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  // Plugins should not be copied or assigned.
  TracksForCali(TracksForCali const &) = delete;
  TracksForCali(TracksForCali &&) = delete;
  TracksForCali & operator = (TracksForCali const &) = delete;
  TracksForCali & operator = (TracksForCali &&) = delete;
  
  // Required functions.
  void analyze(art::Event const & e) override;
  
  // Selected optional functions
  void beginJob() override;
  void endJob() override;
  void reset();

  // HighLAND functions
  AnaSpillPD*         MakeSpill()       { return new AnaSpillPD(); }
  AnaBunchPD*         MakeBunch()       { return new AnaBunchPD(); }
  AnaBeamPD*          MakeBeam()        { return new AnaBeamPD(); }
  AnaDataQualityB*    MakeDataQuality() { return new AnaDataQuality(); }
  AnaEventInfoPD*     MakeEventInfo()   { return new AnaEventInfoPD(); }

  AnaTrueParticlePD*  MakeTrueParticle(){ return new AnaTrueParticlePD(); }
  AnaTrueVertex*      MakeTrueVertex()  { return new AnaTrueVertex(); }
  AnaParticlePD*      MakeParticle()    { return new AnaParticlePD(); }

  // Other functions
  void FillEventInfo(AnaEventInfoPD& info, art::Event const& evt);
  void FillParticleInfo(AnaParticlePD* part, const recob::Track* track);
  void FillHitInfo(AnaHitPD* hit, const anab::Calorimetry* calo, int ihit);
  const anab::Calorimetry* GetCaloForTrack(std::vector<art::Ptr<anab::Calorimetry>> calos);
  bool IsStoppingTrack(const recob::Track* track);
  bool IsBrokenTrack(const recob::Track* track, std::vector<art::Ptr<recob::Track>> trackVec, int itrack);
  bool IsLongTrack(const recob::Track* track);
  void FillTree(AnaSpillPD* spill);
  
private:

  TTree* fTree;
  TTree* fHeaderTree;
  AnaSpillPD* fspill;

  // fcl parameters
  std::string fPFParticleTag;
  std::string fTrackerTag;
  std::string fHitTag;
  std::string fCalorimetryTag;
  double fNominalBeamMom;
};

//*****************************************************************************
highlandAnalysis::TracksForCali::TracksForCali(fhicl::ParameterSet const & p)
//*****************************************************************************
  :
  EDAnalyzer(p),
  fTrackerTag(p.get<std::string>("TrackerTag")),
  fHitTag(p.get<std::string>("HitTag")),
  fCalorimetryTag(p.get<std::string>("CalorimetryTag")),
  fNominalBeamMom(p.get<double>("NominalBeamMom")){
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::analyze(art::Event const & evt){
//*****************************************************************************

  //create a spill for each event and fill event info
  AnaSpillPD* spill = MakeSpill();
  spill->EventInfo = MakeEventInfo();
  FillEventInfo(*static_cast<AnaEventInfoPD*>(spill->EventInfo), evt);

  //Crete bunch
  AnaBunch* bunch = MakeBunch();
  spill->Bunches.push_back(bunch);

  //get necessary objecsts and information 
  //tracks
  std::vector<art::Ptr<recob::Track>> trackVec;
  auto trackHandle = evt.getHandle< std::vector<recob::Track> >(fTrackerTag);
  if(trackHandle){
    art::fill_ptr_vector(trackVec, trackHandle);
  }
  else return;

  //hits associated to each track
  art::FindManyP<recob::Hit> hits_track_assn(trackHandle, evt, fTrackerTag);
  
  //calorimetry associated to each track
  art::FindManyP<anab::Calorimetry> calos_track_assn(trackHandle, evt, fCalorimetryTag);
  if(!calos_track_assn.isValid()){
    std::cout << "Track-Calo association : " << fCalorimetryTag << " not found" << std::endl;
    return;
  }
  
  //Main loop
  //loop over tracks
  for(int itrack = 0; itrack < (int)trackVec.size(); itrack++){
    const recob::Track* track = trackVec[itrack].get();

    //check this track stops within the detector, it is not broken and is long enough
    if(!IsStoppingTrack(track) || IsBrokenTrack(track,trackVec,itrack) || !IsLongTrack(track))
      continue;

    //Create AnaParticle and fill some info
    AnaParticlePD* part = MakeParticle();
    FillParticleInfo(part, track);

    //Get calorimetry associated to this track for the collection plane
    const anab::Calorimetry *calo = GetCaloForTrack(calos_track_assn.at(itrack));
    if(!calo)return;
    
    //loop over hits in calorimetry
    for(int ihit = 0; ihit < (int)calo->dQdx().size(); ihit++){
      //create a highland hit, fill hit info and add it to the vector of hits of the particle 
      AnaHitPD hit;
      FillHitInfo(&hit,calo,ihit);
      part->Hits[2].push_back(hit);
    }
    
    //add the particle to the bunch
    bunch->Particles.push_back(part);
  }

  FillTree(spill);
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::FillEventInfo(AnaEventInfoPD& info, art::Event const& evt){
//*****************************************************************************
  
  info.Run    = evt.run();
  info.SubRun = evt.subRun();
  info.Event  = evt.id().event();
  info.IsMC   = !evt.isRealData();
  info.NominalBeamMom = fNominalBeamMom;
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::FillParticleInfo(AnaParticlePD* part, const recob::Track* track){
//*****************************************************************************
  
  part->Type = AnaParticlePD::kTrack;
  
  part->PositionStart[0] = track->Start().X();
  part->PositionStart[1] = track->Start().Y();
  part->PositionStart[2] = track->Start().Z();
  
  part->PositionEnd[0] = track->End().X();
  part->PositionEnd[1] = track->End().Y();
  part->PositionEnd[2] = track->End().Z();
    
  part->DirectionStart[0] = track->StartDirection().X();
  part->DirectionStart[1] = track->StartDirection().Y();
  part->DirectionStart[2] = track->StartDirection().Z();
  
  part->DirectionEnd[0] = track->EndDirection().X();
  part->DirectionEnd[1] = track->EndDirection().Y();
  part->DirectionEnd[2] = track->EndDirection().Z();
    
  part->Length = track->Length();
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::FillHitInfo(AnaHitPD* hit, const anab::Calorimetry* calo, int ihit){
//*****************************************************************************

  hit->dQdx          = calo->dQdx().at(ihit);
  hit->dEdx          = calo->dEdx().at(ihit);
  hit->ResidualRange = calo->ResidualRange().at(ihit);

  hit->Position.SetXYZ(calo->XYZ().at(ihit).X(), calo->XYZ().at(ihit).Y(), calo->XYZ().at(ihit).Z());
}

//*****************************************************************************
bool highlandAnalysis::TracksForCali::IsStoppingTrack(const recob::Track* track){
//*****************************************************************************
  
  double startX = track->Start().X();
  double startY = track->Start().Y();
  double startZ = track->Start().Z();
  double endX = track->End().X();
  double endY = track->End().Y();
  double endZ = track->End().Z();
  
  return(((std::abs(startX)>330 ||  startY<50 || startY>550 || startZ<50 || startZ>645) && 
	  !(std::abs(endX)>330 ||  endY<50 || endY>550 || endZ<50 || endZ>645))
	 ||
	 (!(std::abs(startX)>330 ||  startY<50 || startY>550 || startZ<50 || startZ>645) && 
	  (std::abs(endX)>330 ||  endY<50 || endY>550 || endZ<50 || endZ>645)));
}

//*****************************************************************************
bool highlandAnalysis::TracksForCali::IsBrokenTrack(const recob::Track* track, std::vector<art::Ptr<recob::Track>> trackVec, int itrack){
//*****************************************************************************
  
  bool IsBroken = false;
  
  //track geometryic information
  TVector3 pos_start = track->Vertex<TVector3>();
  TVector3 dir_start = track->VertexDirection<TVector3>();
  TVector3 pos_end   = track->End<TVector3>();
  TVector3 dir_end   = track->EndDirection<TVector3>();
    
  for(int i = 0; i < (int)trackVec.size(); i++){
    if(i == itrack)continue;
    const recob::Track* track_2 = trackVec[i].get();

    //second track geometric info
    TVector3 pos_start_2 = track_2->Vertex<TVector3>();
    TVector3 dir_start_2= track_2->VertexDirection<TVector3>();
    TVector3 pos_end_2 = track_2->End<TVector3>();
    TVector3 dir_end_2   = track_2->EndDirection<TVector3>();
    
    //from Michelremoving module, two possibilities to assume a track is broken
    //1st one, two tracks close and aligned
    if(((std::abs(((pos_end_2.Y()-pos_start_2.Y())/(pos_end_2.Z()-pos_start_2.Z()))*(pos_end.Z()-pos_start_2.Z())+pos_start_2.Y()-pos_end.Y()) < 30 || 
	std::abs(((pos_end_2.Y()-pos_start_2.Y())/(pos_end_2.Z()-pos_start_2.Z()))*(pos_start.Z()-pos_start_2.Z())+pos_start_2.Y()-pos_start.Y()) < 30) 
       && 
       (std::abs(dir_end*dir_start_2) > 0.97 || 
	std::abs(dir_start*dir_start_2) > 0.97 || 
	std::abs(dir_end*dir_end_2) > 0.97 || 
	std::abs(dir_start*dir_end_2) > 0.97))

      ||
       //2nd one, two tracks close not that close but super aligned
       ((std::abs(((pos_end_2.Y()-pos_start_2.Y())/(pos_end_2.Z()-pos_start_2.Z()))*(pos_end.Z()-pos_start_2.Z())+pos_start_2.Y()-pos_end.Y()) < 50 ||
	 std::abs(((pos_end_2.Y()-pos_start_2.Y())/(pos_end_2.Z()-pos_start_2.Z()))*(pos_start.Z()-pos_start_2.Z())+pos_start_2.Y()-pos_start.Y()) < 50)
       &&
       (std::abs(dir_end*dir_start_2) > 0.998 ||
	std::abs(dir_start*dir_start_2) > 0.998 ||
	std::abs(dir_end*dir_end_2) > 0.998 ||
	std::abs(dir_start*dir_end_2) > 0.998)))
      {
	IsBroken = true;
	break;
      }
  }

  return IsBroken; 
}

//*****************************************************************************
bool highlandAnalysis::TracksForCali::IsLongTrack(const recob::Track* track){
//*****************************************************************************

  return track->Length() > 100.;
}

//*****************************************************************************
const anab::Calorimetry* highlandAnalysis::TracksForCali::GetCaloForTrack(std::vector<art::Ptr<anab::Calorimetry>> calos){
//*****************************************************************************

  //safety check
  if(calos.empty())return NULL;

  //get collection plane index (it changes within productions and data/MC)
  int plane_index = -1;
  for(int i = 0; i < (int)calos.size(); i++){
    if(calos[i]->PlaneID().Plane == 2){
      plane_index = i;
      break;
    }
  }
  if(plane_index==-1){
    std::cout << "No collection plane founde" << std::endl;
    return NULL;
  }
  
  return calos[plane_index].get();
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::FillTree(AnaSpillPD* spill){
//*****************************************************************************
  
  //if spill has been correctly saved, delete previous one
  if(fspill)delete fspill;
  fspill = NULL;

  //clone the new spill and fill the three
  fspill = spill->Clone();
  fTree->Fill();
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::beginJob(){
//*****************************************************************************

  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("MiniTree","event model tree");
  fspill = NULL;
  fTree->Branch("Spill", "AnaSpillPD", &fspill,64000,1);  
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::endJob(){
//*****************************************************************************
  
  //create header file
  art::ServiceHandle<art::TFileService> tfs;
  fHeaderTree = tfs->make<TTree>("header","header tree");
  Header* headerp = NULL;                                                                                                         
  fHeaderTree->Branch("POTInfo","Header",&headerp,32000,0);                                                                
  fHeaderTree->Fill();

  //delete last spill before exiting
  delete fspill;
}

//*****************************************************************************
void highlandAnalysis::TracksForCali::reset(){
//*****************************************************************************
  
}

DEFINE_ART_MODULE(highlandAnalysis::TracksForCali)
